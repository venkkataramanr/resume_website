'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const path = require('path');

const chokidar = require('chokidar');

const spawn = require('child-process-ext/spawn');

const dependencyTree = require('dependency-tree');

const _require = require('@serverless/platform-client'),
      ServerlessSDK = _require.ServerlessSDK;

const _require2 = require('@serverless/platform-sdk'),
      getAccessKeyForTenant = _require2.getAccessKeyForTenant;

const _require3 = require('lodash'),
      isEqual = _require3.isEqual;

const findProcess = require('find-process');

const isAuthenticated = require('./isAuthenticated');

const throwAuthError = require('./throwAuthError');
/**
 * Pass along env variables, and also SLS_DEV_MODE which will capture logs for Serverless Studio
 */


const execOptions = {
  env: _objectSpread({}, process.env, {
    SLS_DEV_MODE: true
  }),
  cwd: process.cwd(),
  stdio: 'inherit'
};
const slsCommand = 'serverless';
/**
 * All serverless configuration file variants will be watched. Note that the absolute
 * path for this files is computed, since that is how chokidar is configured to watch
 * these files.
 */

const possibleServerlessConfigFileVariants = ['serverless.yml', 'serverless.yaml', 'serverless.json', 'serverless.js'].map(configFile => path.resolve(configFile));

module.exports = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (ctx) {
    const _ctx$sls = ctx.sls,
          _ctx$sls$service = _ctx$sls.service,
          app = _ctx$sls$service.app,
          org = _ctx$sls$service.org,
          ServerlessError = _ctx$sls.classes.Error;
    const sls = ctx.sls;

    if (!isAuthenticated()) {
      throwAuthError(sls);
    }

    if (!org) throw new ServerlessError('Missing `org` setting', 'DASHBOARD_MISSING_ORG');
    if (!app) throw new ServerlessError('Missing `app` setting', 'DASHBOARD_MISSING_APP');
    /**
     * Stage used for development. By default, pick a generated stage,
     * unless specified by the user.
     */

    let deployToStage = ctx.provider.getStage();
    let deployToRegion = 'us-east-1';
    const _sls$processedInput$o = sls.processedInput.options,
          stage = _sls$processedInput$o.stage,
          region = _sls$processedInput$o.region,
          info = _sls$processedInput$o.info,
          autoStage = _sls$processedInput$o.autoStage;

    if (stage) {
      deployToStage = stage;
    }

    if (region) {
      deployToRegion = region;
    }
    /**
     * If specified, automatically pick a random stage, and remove it on exit
     */


    if (autoStage) {
      deployToStage = `${process.env.USER || 'dev'}-${Math.floor(Math.random() * 100000)}`;
    }
    /**
     * Informational flag, used by parent watch process
     */


    if (info) {
      let endpoints = [];
      /**
       * Close your eyes.
       *
       * Call 'serverless info' here to get the endpoints and pull them out of the output, if there are any.
       */

      try {
        const _yield$spawn = yield spawn(slsCommand, ['info', `--stage=${deployToStage}`, `--region=${deployToRegion}`]),
              stdoutBuffer = _yield$spawn.stdoutBuffer;

        endpoints = stdoutBuffer.toString().match(/(ANY|GET|POST|PUT|PATCH|HEAD|OPTIONS|DELETE) - (.*)/g).map(stringEndpoint => {
          const _stringEndpoint$split = stringEndpoint.split(' - '),
                _stringEndpoint$split2 = _slicedToArray(_stringEndpoint$split, 2),
                method = _stringEndpoint$split2[0],
                endpoint = _stringEndpoint$split2[1];

          return {
            method,
            endpoint
          };
        });
      } catch (e) {}
      /**
       * If we fail, it's probably because this this stage is not
       * yet deployed.
       */

      /**
       * Communicate relevant configuration settings to the parent process (sls dev):
       *
       *  - General app/org information
       *  - Send new infra/functions to websocket
       *  - Detect new functions to watch
       */


      process.stdout.write(JSON.stringify({
        meta: {
          app: sls.service.app,
          org: sls.service.org,
          service: sls.service.service,
          region: deployToRegion,
          stage: deployToStage
        },
        functions: sls.service.functions,
        resources: sls.service.resources,
        endpoints
      }));
      return;
    }

    sls.cli.log('Starting Serverless dev mode...');
    /**
     * As a pseudo-failsafe, don't support the prod stage to limit WebSocket traffic
     */

    if (deployToStage === 'prod') {
      sls.cli.log("Stage 'prod' cannot be used with 'serverless dev'");
      return;
    }
    /**
     * Check to see if 'serverless dev' is already running
     */


    const processes = yield findProcess('name', /(serverless|sls) dev/g);

    if (processes.length === 0) {
      sls.cli.log('Failed to detect running serverless process. Exiting.');
      return;
    }
    /**
     * Only one process can be running
     */


    if (processes.length > 1) {
      sls.cli.log("Only one instance of 'serverless dev' can be running");
      return;
    }

    const accessKey = yield getAccessKeyForTenant(sls.service.org);
    const sdk = new ServerlessSDK({
      platformStage: process.env.SERVERLESS_PLATFORM_STAGE || 'prod',
      accessKey
    });
    /**
     * Primary app state. This is communicated back-and-forth over the socket with the web
     * client.
     */

    let appState = {
      /**
       * This is a 'sls deploy' (not a function deploy). It's required
       * for the initial build, and also any changes to the the serverless.yml
       * file
       */
      isDeploying: false,

      /**
       * Mapping of (function name) <String> -> <Boolean>
       * to determine if a function is already deploying
       */
      isFunctionDeploying: {},

      /**
       * These are populated from the 'sls dev --info' output, which
       * is a combination of a parsed serverless.yml, and outputs
       * from 'serverless info' (namely the endpoints)
       */
      functions: {},
      resources: {},
      endpoints: []
    };
    /**
     * Connect to the WebSocket
     */

    yield sdk.connect({
      orgName: sls.service.org,
      onEvent: function () {
        var _onEvent = _asyncToGenerator(function* ({
          event,
          data
        }) {
          const clientType = data.clientType;

          if (event === 'studio.connect') {
            /**
             * If a web client connects to the socket, then send the appState. Also issue
             * another 'studio.connect' to communicate the the CLI is in watch mode. This
             * will handle a case where the web client refreshes.
             */
            if (clientType === 'web') {
              appState.isWebConnected = true;
              yield sdk.publishSync({
                event: 'studio.connect',
                data: {
                  clientType: 'cli'
                }
              });
              yield updateAppState();
              yield publishAppState();
            }

            if (clientType === 'cli') {
              appState.isCliConnected = true;
            }
          }
        });

        function onEvent(_x2) {
          return _onEvent.apply(this, arguments);
        }

        return onEvent;
      }()
    });
    sls.cli.log('Connected to the Serverless Platform');
    yield sdk.publishSync({
      event: 'studio.connect',
      data: {
        clientType: 'cli'
      }
    });

    if (autoStage) {
      sls.cli.log(`Auto stage generation enabled. Will deploy to stage: "${deployToStage}"...`);
      sls.cli.log(`Note: exiting dev mode will remove stage "${deployToStage}"...`);
    }

    const disconnect = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* () {
        if (sdk.isConnected()) {
          yield sdk.publishSync({
            event: 'studio.disconnect',
            data: {
              clientType: 'cli'
            }
          });
          yield sdk.disconnect();
          process.stdout.write('\n');
          sls.cli.log('Disconnected from the Serverless Platform');
        }
      });

      return function disconnect() {
        return _ref2.apply(this, arguments);
      };
    }();

    const cleanup = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* () {
        yield disconnect();
        /**
         * Tear down the stage if in "auto-stage" mode
         */

        if (autoStage) {
          process.stdout.write('\n');
          sls.cli.log(`Cleaning up stage "${deployToStage}"...`);
          yield spawn(slsCommand, ['remove', `--stage=${deployToStage}`, `--region=${deployToRegion}`], execOptions);
        }

        process.exit(0);
      });

      return function cleanup() {
        return _ref3.apply(this, arguments);
      };
    }();

    let filenameToFunctionsMapping = {};
    const functionToFilenames = {};
    /**
     * Capture ctrl+c and remove the stage that we setup
     */

    process.on('SIGINT', cleanup);
    process.on('uncaughtException', disconnect);
    process.on('exit', cleanup);

    const getServerlessInfo = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(function* () {
        const filenameToFunctions = {};
        const trackedFiles = [];
        /**
         * Issue the --info variant of this command to get a parsed JSON output
         * of the serverless.yml to determine HTTP endpoints
         */

        const _yield$spawn2 = yield spawn(slsCommand, ['dev', '--info', `--stage=${deployToStage}`], {
          env: process.env
        }),
              stdoutBuffer = _yield$spawn2.stdoutBuffer;

        let output = {};

        try {
          output = JSON.parse(stdoutBuffer.toString());
        } catch (e) {
          /**
           * If you ctrl+c during "serverless dev --info" to extract parsed
           * yml information and HTTP endpoints, this will blow up. For now,
           * just return some empty state objects so we can exit cleanly
           * without an error.
           */
          return {
            filenameToFunctions,
            trackedFiles,
            output,
            functions: []
          };
        }

        const _output = output,
              functions = _output.functions;
        /**
         * Use the handler path to reconstruct the path to the entry module
         */

        Object.keys(functions).forEach(functionName => {
          const _path$parse = path.parse(functions[functionName].handler),
                dir = _path$parse.dir,
                name = _path$parse.name;

          const handlerEntry = `${path.join(dir, name)}.js`;
          /**
           * Determine modules required by the entry point of the handler
           */

          const list = dependencyTree.toList({
            filename: handlerEntry,
            directory: process.cwd(),

            /**
             * Don't try to watch files in node_modules
             */
            filter: filename => filename.indexOf('node_modules') === -1
          });
          /**
           * Store all files that make up this function
           */

          functionToFilenames[functionName] = list;
          /**
           * For convenience, map all watched modules to function(s)
           */

          list.forEach(watchedFilename => {
            /**
             * Functions already mapped to this file
             */
            const funcs = filenameToFunctions[watchedFilename] || [];
            filenameToFunctions[watchedFilename] = new Set([...funcs, functionName]);
          });
          trackedFiles.push(...list);
        });
        return {
          filenameToFunctions,
          trackedFiles,
          output,
          functions
        };
      });

      return function getServerlessInfo() {
        return _ref4.apply(this, arguments);
      };
    }();

    const updateAppState = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(function* () {
        const _yield$getServerlessI = yield getServerlessInfo(),
              output = _yield$getServerlessI.output;

        appState = _objectSpread({}, appState, {}, output);
      });

      return function updateAppState() {
        return _ref5.apply(this, arguments);
      };
    }();
    /**
     * Communicate application state to socket
     */


    const publishAppState = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator(function* (overrides) {
        yield sdk.publishSync({
          event: 'studio.state',
          data: _objectSpread({}, appState, {}, overrides)
        });
      });

      return function publishAppState(_x3) {
        return _ref6.apply(this, arguments);
      };
    }();
    /**
     * Deploy the stack
     */


    const deploy = /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator(function* (isRedeploying) {
        if (appState.isDeploying) {
          return;
        }

        sls.cli.log(`${isRedeploying ? 'Redeploying' : 'Deploying'} to stage "${deployToStage}". This may take a few minutes...`);
        appState.isDeploying = true;
        yield publishAppState();
        yield spawn(slsCommand, ['deploy', `--stage=${deployToStage}`, `--region=${deployToRegion}`], execOptions);
        appState.isDeploying = false;
        sls.cli.log(`Succesfully deployed stage "${deployToStage}"`);
        yield updateAppState();
        yield publishAppState();
      });

      return function deploy(_x4) {
        return _ref7.apply(this, arguments);
      };
    }();
    /**
     * Communicate initial state of the serverless.yml
     */


    sls.cli.log('Sending initial app state...');
    yield updateAppState();
    yield publishAppState({
      isDeploying: true
    });
    /**
     * Deploy the serverless.yml file
     */

    yield deploy();
    /**
     * Compute new watch files. Only rewatch new files if parsing the serverless.yml file is successfull.
     */

    const rewatchFiles = /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator(function* () {
        /**
         * Compute new watch files. Only rewatch new files if parsing the serverless.yml file is successfull.
         */
        const _yield$getServerlessI2 = yield getServerlessInfo(),
              filenameToFunctions = _yield$getServerlessI2.filenameToFunctions,
              trackedFiles = _yield$getServerlessI2.trackedFiles;

        filenameToFunctionsMapping = filenameToFunctions;
        /**
         * Remove all paths
         */

        yield watcher.unwatch('*');
        /**
         * Re-watch new files
         */

        watcher.add([...possibleServerlessConfigFileVariants, ...trackedFiles]);
      });

      return function rewatchFiles() {
        return _ref8.apply(this, arguments);
      };
    }();
    /**
     * Create a new watcher. By default don't watch anything. The serverless.yml file
     * will be parsed for function handlers. Those handlers will have their dependency
     * trees mapped, and those files will be added dynamically by `rewatchFiles()`
     */


    const watcher = chokidar.watch([], {
      /**
       * Tracked files are absolute, and explicit. By default cwd is the currently working directory,
       * which means the mapping between function and files will be wrong.
       */
      cwd: '/'
    });
    sls.cli.log('Building function dependency watch list...');
    yield rewatchFiles();
    sls.cli.log(`Tracking ${Object.keys(functionToFilenames).length} function handler(s), and their dependencies...`);
    watcher.on('ready', () => {
      sls.cli.log('Watching for changes...');
    });
    /**
     * Watch for file changes
     */

    watcher.on('change', /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator(function* (filepath) {
        const _appState = appState,
              isFunctionDeploying = _appState.isFunctionDeploying;
        /**
         * Force resolved file path to be absolute.
         */

        const resolvedFilepath = path.normalize(`${path.sep}${filepath}`);
        /**
         * A serverless.ya(m)l file has changed
         */

        if (possibleServerlessConfigFileVariants.includes(resolvedFilepath) && !appState.isDeploying) {
          sls.cli.log('serverless configuration changed. Checking for function changes...');
          /**
           * Compare the function (names) in the serverless.yml file
           * with what's already in the app state. We need to redeploy
           * the stack if:
           *
           *  1. A new function has ben added
           *  2. A function has been renamed
           *  3. If you change settings of a function
           */

          const _yield$getServerlessI3 = yield getServerlessInfo(),
                functions = _yield$getServerlessI3.functions;

          if (!isEqual(functions, appState.functions)) {
            sls.cli.log('Detected function configuration changes...');
            sls.cli.log(`Stage "${deployToStage}" will be redeployed to reflect these changes...`);
            yield deploy(true);
            yield updateAppState();
            yield publishAppState();
            rewatchFiles();
          } else {
            sls.cli.log('No function changes detected. Continuing...');
          }

          return;
        }

        const functionNames = filenameToFunctionsMapping[resolvedFilepath];

        if (!functionNames) {
          return;
        }
        /**
         * Only deploy a function that is not already deploying
         */


        const functionsNeedingDeploy = [...functionNames].filter(functionName => !isFunctionDeploying[functionName]);
        /**
         * Mark all functions as deploying, and communicate that state
         */

        functionsNeedingDeploy.forEach(functionName => {
          sls.cli.log(`${functionName}: changed. Redeploying...`);
          isFunctionDeploying[functionName] = true;
        });

        if (functionsNeedingDeploy.length > 0) {
          yield publishAppState();
        }
        /**
         * Redeploy all changed functions
         */


        yield Promise.all(functionsNeedingDeploy.map( /*#__PURE__*/function () {
          var _ref10 = _asyncToGenerator(function* (functionName) {
            /**
             * Redeploy the function
             */
            try {
              yield spawn(slsCommand, ['deploy', 'function', `--function=${functionName}`, `--stage=${deployToStage}`], execOptions);
            } catch (e) {
              /**
               * This ocassionally fails, although I haven't yet been able
               * to track down why.
               */
            } finally {
              isFunctionDeploying[functionName] = false;
            }
          });

          return function (_x6) {
            return _ref10.apply(this, arguments);
          };
        }()));

        if (functionsNeedingDeploy.length > 0) {
          yield publishAppState();
          sls.cli.log('Watching for changes...');
        }
      });

      return function (_x5) {
        return _ref9.apply(this, arguments);
      };
    }());
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
//# sourceMappingURL=dev.js.map